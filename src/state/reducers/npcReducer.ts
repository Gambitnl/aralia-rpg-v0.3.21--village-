/**
 * @file src/state/reducers/npcReducer.ts
 * A slice reducer that handles NPC memory state changes.
 */
import { GameState, SuspicionLevel, GoalStatus, KnownFact } from '../../types';
import { AppAction } from '../actionTypes';

export function npcReducer(state: GameState, action: AppAction): Partial<GameState> {
  switch (action.type) {
    case 'UPDATE_NPC_DISPOSITION': {
      const { npcId, amount } = action.payload;
      const currentMemory = state.npcMemory[npcId];
      if (!currentMemory) return {};

      const newDisposition = Math.max(-100, Math.min(100, currentMemory.disposition + amount));

      return {
        npcMemory: {
          ...state.npcMemory,
          [npcId]: {
            ...currentMemory,
            disposition: newDisposition,
          },
        },
      };
    }

    case 'ADD_NPC_KNOWN_FACT': {
      const { npcId, fact } = action.payload; // fact is now a KnownFact object
      const currentMemory = state.npcMemory[npcId];
      if (!currentMemory) return {};

      // Avoid adding duplicate facts by checking the text content
      if (currentMemory.knownFacts.some(existingFact => existingFact.text === fact.text)) {
        return {};
      }

      return {
        npcMemory: {
          ...state.npcMemory,
          [npcId]: {
            ...currentMemory,
            knownFacts: [...currentMemory.knownFacts, fact],
          },
        },
      };
    }

    case 'UPDATE_NPC_SUSPICION': {
      const { npcId, newLevel } = action.payload;
      const currentMemory = state.npcMemory[npcId];
      if (!currentMemory || currentMemory.suspicion === newLevel) return {};

      return {
        npcMemory: {
          ...state.npcMemory,
          [npcId]: {
            ...currentMemory,
            suspicion: newLevel,
          },
        },
      };
    }
    
    // This case handles updating the status of a specific goal for an NPC.
    // It finds the correct NPC and goal, then updates the status immutably.
    // This is the core state logic for progressing NPC motivations.
    case 'UPDATE_NPC_GOAL_STATUS': {
        const { npcId, goalId, newStatus } = action.payload;
        const currentMemory = state.npcMemory[npcId];
        if (!currentMemory || !currentMemory.goals) return {};
        
        const goalIndex = currentMemory.goals.findIndex(g => g.id === goalId);
        if (goalIndex === -1 || currentMemory.goals[goalIndex].status === newStatus) {
            return {}; // Goal not found or status is already the same
        }

        const newGoals = [...currentMemory.goals];
        newGoals[goalIndex] = { ...newGoals[goalIndex], status: newStatus };

        return {
            npcMemory: {
                ...state.npcMemory,
                [npcId]: {
                    ...currentMemory,
                    goals: newGoals,
                },
            },
        };
    }
    
    // This new case efficiently applies all state changes generated by a single Gossip Event.
    // It iterates through the payload, updating multiple NPCs' memories in one go.
    // This is crucial for performance, preventing many separate re-renders.
    case 'PROCESS_Gossip_UPDATES': {
        const payload = action.payload;
        const newNpcMemory = { ...state.npcMemory };
        let hasChanges = false;

        for (const npcId in payload) {
            const update = payload[npcId];
            const currentMemory = newNpcMemory[npcId];

            if (currentMemory) {
                hasChanges = true;
                const newFacts = update.newFacts.filter(
                    newFact => !currentMemory.knownFacts.some(existing => existing.text === newFact.text)
                );
                
                const newDisposition = Math.max(-100, Math.min(100, currentMemory.disposition + update.dispositionNudge));

                if (newFacts.length > 0 || newDisposition !== currentMemory.disposition) {
                    newNpcMemory[npcId] = {
                        ...currentMemory,
                        disposition: newDisposition,
                        knownFacts: [...currentMemory.knownFacts, ...newFacts],
                    };
                }
            }
        }
        return hasChanges ? { npcMemory: newNpcMemory } : {};
    }

    // This action updates the last time the player interacted with a specific NPC.
    // This is used for the disposition drift mechanic during a long rest.
    case 'UPDATE_NPC_INTERACTION_TIMESTAMP': {
      const { npcId, timestamp } = action.payload;
      const currentMemory = state.npcMemory[npcId];
      if (!currentMemory) return {};

      return {
        npcMemory: {
          ...state.npcMemory,
          [npcId]: {
            ...currentMemory,
            lastInteractionTimestamp: timestamp,
          },
        },
      };
    }

    // This action replaces the entire npcMemory state slice with a new one.
    // It is used by the long rest world event handler for a single, performant update
    // after calculating decay, pruning, and disposition drift.
    case 'BATCH_UPDATE_NPC_MEMORY': {
      return { npcMemory: action.payload };
    }


    default:
      return {};
  }
}
